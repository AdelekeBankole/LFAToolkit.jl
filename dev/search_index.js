var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"A. Brandt. Multi-level adaptive solutions to boundary-value problems. Math. Comp., 31(138):33-390, 1977.","category":"page"},{"location":"private/#Private-API","page":"Private API","title":"Private API","text":"","category":"section"},{"location":"private/#Mesh","page":"Private API","title":"Mesh","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"LFAToolkit.Mesh","category":"page"},{"location":"private/#LFAToolkit.Mesh","page":"Private API","title":"LFAToolkit.Mesh","text":"Rectangular mesh with independent scaling in each dimesion\n\n\n\n\n\n","category":"type"},{"location":"private/#Basis","page":"Private API","title":"Basis","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"LFAToolkit.Basis\nLFAToolkit.gaussquadrature\nLFAToolkit.lobattoquadrature\nLFAToolkit.getnumbernodes\nLFAToolkit.getnumberquadraturepoints\nLFAToolkit.getinterpolation\nLFAToolkit.getgradient\nLFAToolkit.getquadratureweights","category":"page"},{"location":"private/#LFAToolkit.Basis","page":"Private API","title":"LFAToolkit.Basis","text":"Finite element basis for function spaces and test spaces\n\n\n\n\n\n","category":"type"},{"location":"private/#LFAToolkit.gaussquadrature","page":"Private API","title":"LFAToolkit.gaussquadrature","text":"gaussquadrature()\n\nConstruct a Gauss-Legendre quadrature\n\nquadraturepoints, quadratureweights = LFAToolkit.gaussquadrature(5);\n\n# verify\ntruepoints = [-sqrt(5 + 2*sqrt(10/7))/3, -sqrt(5 - 2*sqrt(10/7))/3, 0.0, sqrt(5 - 2*sqrt(10/7))/3, sqrt(5 + 2*sqrt(10/7))/3];\ntrueweights = [(322-13*sqrt(70))/900, (322+13*sqrt(70))/900, 128/225, (322+13*sqrt(70))/900, (322-13*sqrt(70))/900];\n\ndiff = truepoints - quadraturepoints;\nif abs(max(diff...)) > 1e-15\n    println(\"Incorrect quadrature points\");\nend\n\ndiff = trueweights - quadratureweights;\nif abs(abs(max(diff...))) > 1e-15\n    println(\"Incorrect quadrature weights\");\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/#LFAToolkit.lobattoquadrature","page":"Private API","title":"LFAToolkit.lobattoquadrature","text":"lobattoquadrature()\n\nConstruct a Gauss-Lobatto quadrature\n\nquadraturepoints = LFAToolkit.lobattoquadrature(5, false);\n\n# verify\ntruepoints = [-1.0, -sqrt(3/7), 0.0, sqrt(3/7), 1.0];\n\ndiff = truepoints - quadraturepoints;\nif abs(max(diff...)) > 1e-15\n    println(\"Incorrect quadrature points\");\nend\n\n# output\n\n\nquadraturepoints, quadratureweights = LFAToolkit.lobattoquadrature(5, true);\n\n# verify\ntruepoints = [-1.0, -sqrt(3/7), 0.0, sqrt(3/7), 1.0];\ntrueweights = [1/10, 49/90, 32/45, 49/90, 1/10];\n\ndiff = truepoints - quadraturepoints;\nif abs(max(diff...)) > 1e-15\n    println(\"Incorrect quadrature points\");\nend\n\ndiff = trueweights - quadratureweights;\nif abs(abs(max(diff...))) > 1e-15\n    println(\"Incorrect quadrature weights\");\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/#LFAToolkit.getnumbernodes","page":"Private API","title":"LFAToolkit.getnumbernodes","text":"getnumbernodes()\n\nGet the number of nodes for the basis\n\nbasis = TensorH1LagrangeBasis(4, 3, 2);\nnumbernodes = LFAToolkit.getnumbernodes(basis);\n\n# verify\nif numbernodes != 16\n    println(\"Incorrect number of nodes\")\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/#LFAToolkit.getnumberquadraturepoints","page":"Private API","title":"LFAToolkit.getnumberquadraturepoints","text":"getnumberquadraturepoints()\n\nGet the number of quadrature points for the basis\n\nbasis = TensorH1LagrangeBasis(4, 3, 2);\nquadraturepoints = LFAToolkit.getnumberquadraturepoints(basis);\n    \n# verify\nif quadraturepoints != 9\n    println(\"Incorrect number of quadrature points\")\nend\n    \n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/#LFAToolkit.getinterpolation","page":"Private API","title":"LFAToolkit.getinterpolation","text":"getinterpolation()\n\nGet full interpolation matrix for basis\n\nbasis = TensorH1LagrangeBasis(4, 3, 1);\ninterpolation = LFAToolkit.getinterpolation(basis);\n\n# verify\nfor i in 1:3\n    sum = 0.0\n    for j = 1:4\n        sum += interpolation[i, j];\n    end\n    if abs(sum - 1.0) > 1e-15\n        println(\"Incorrect interpolation matrix\")\n    end\nend\n\n# output\n\n\nbasis = TensorH1LagrangeBasis(4, 3, 2);\ninterpolation = LFAToolkit.getinterpolation(basis);\n\n# verify\nfor i in 1:3^2\n    total = sum(interpolation[i, :]);\n    if abs(total - 1.0) > 1e-15\n        println(\"Incorrect interpolation matrix\")\n    end\nend\n\n# output\n\n\nbasis = TensorH1LagrangeBasis(4, 3, 3);\ninterpolation = LFAToolkit.getinterpolation(basis);\n\n# verify\nfor i in 1:3^3\n    total = sum(interpolation[i, :]);\n    if abs(total - 1.0) > 1e-15\n        println(\"Incorrect interpolation matrix\")\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/#LFAToolkit.getgradient","page":"Private API","title":"LFAToolkit.getgradient","text":"getgradient()\n\nGet full gradient matrix for basis\n\nbasis = TensorH1LagrangeBasis(4, 3, 1);\ngradient = LFAToolkit.getgradient(basis);\n\n# verify\nfor i in 1:3\n    sum = 0.0\n    for j = 1:4\n        sum += gradient[i, j];\n    end\n    if abs(sum) > 1e-15\n        println(\"Incorrect gradent matrix\")\n    end\nend\n\n# output\n\n\nbasis = TensorH1LagrangeBasis(4, 3, 2);\ngradient = LFAToolkit.getgradient(basis);\n\n# verify\nfor i in 1:2*3^2\n    total = sum(gradient[i, :]);\n    if abs(total) > 1e-15\n        println(\"Incorrect gradient matrix\")\n    end\nend\n\n# output\n\n\nbasis = TensorH1LagrangeBasis(4, 3, 3);\ngradient = LFAToolkit.getgradient(basis);\n\n# verify\nfor i in 1:3*3^3\n    total = sum(gradient[i, :]);\n    if abs(total) > 1e-14\n        println(\"Incorrect gradient matrix\")\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/#LFAToolkit.getquadratureweights","page":"Private API","title":"LFAToolkit.getquadratureweights","text":"getquadratureweights()\n\nGet full quadrature weights vector for basis\n\nbasis = TensorH1LagrangeBasis(4, 3, 1);\nquadratureweights = LFAToolkit.getquadratureweights(basis);\n\n# verify\ntrueweights = [5/9, 8/9, 5/9];\n\ndiff = trueweights - quadratureweights;\nif abs(abs(max(diff...))) > 1e-15\n    println(\"Incorrect quadrature weights\");\nend\n\n# output\n\n\nbasis = TensorH1LagrangeBasis(4, 3, 2);\nquadratureweights = LFAToolkit.getquadratureweights(basis);\n\n# verify\ntrueweights1d = [5/9, 8/9, 5/9];\ntrueweights = kron(trueweights1d, trueweights1d);\n\ndiff = trueweights - quadratureweights;\nif abs(abs(max(diff...))) > 1e-15\n    println(\"Incorrect quadrature weights\");\nend\n    \n# output\n\n\nbasis = TensorH1LagrangeBasis(4, 3, 3);\nquadratureweights = LFAToolkit.getquadratureweights(basis);\n\n# verify\ntrueweights1d = [5/9, 8/9, 5/9];\ntrueweights = kron(trueweights1d, trueweights1d, trueweights1d);\n\ndiff = trueweights - quadratureweights;\nif abs(abs(max(diff...))) > 1e-15\n    println(\"Incorrect quadrature weights\");\nend\n    \n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/#Operator","page":"Private API","title":"Operator","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"LFAToolkit.getstencil","category":"page"},{"location":"private/#LFAToolkit.getstencil","page":"Private API","title":"LFAToolkit.getstencil","text":"getstencil()\n\nCompute or retrieve the stencil of operator for computing the symbol\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nbasis = TensorH1LagrangeBasis(4, 4, 2);\n    \nfunction massweakform(u::Array{Float64,1}, w::Array{Float64})\n    v = u * w[1]\n    return [v]\nend\n    \n# mass operator\ninputs = [\n    OperatorField(basis, EvaluationMode.interpolation),\n    OperatorField(basis, EvaluationMode.quadratureweights),\n];\noutputs = [OperatorField(basis, EvaluationMode.interpolation)];\nmass = Operator(massweakform, mesh, inputs, outputs);\n    \n# stencil computation\nstencil = LFAToolkit.getstencil(mass);\n\n# verify\nu = ones(4*4);\nv = stencil * u;\n    \ntotal = sum(v);\nif abs(total - 4.0) > 1e-14\n    println(\"Incorrect mass matrix\");\nend\n\n# test caching\nstencil = LFAToolkit.getstencil(mass)\nv = stencil * u;\n    \ntotal = sum(v);\nif abs(total - 4.0) > 1e-14\n    println(\"Incorrect mass matrix\");\nend\n    \n# output\n    \n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nbasis = TensorH1LagrangeBasis(4, 4, 2);\n    \nfunction diffusionweakform(du::Array{Float64,1}, w::Array{Float64})\n    dv = du * w[1]\n    return [dv]\nend\n    \n# diffusion operator\ninputs = [\n    OperatorField(basis, EvaluationMode.gradient),\n    OperatorField(basis, EvaluationMode.quadratureweights),\n];\noutputs = [OperatorField(basis, EvaluationMode.gradient)];\ndiffusion = Operator(diffusionweakform, mesh, inputs, outputs);\n    \n# stencil computation\nstencil = LFAToolkit.getstencil(diffusion);\n    \n# verify\nu = ones(4*4);\nv = stencil * u;\n    \ntotal = sum(v);\nif abs(total) > 1e-14\n    println(\"Incorrect diffusion matrix\");\nend\n    \n# output\n    \n\n\n\n\n\n","category":"function"},{"location":"public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"public/#Mesh","page":"Public API","title":"Mesh","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Mesh1D\nMesh2D\nMesh3D","category":"page"},{"location":"public/#LFAToolkit.Mesh1D","page":"Public API","title":"LFAToolkit.Mesh1D","text":"Mesh1D()\n\nmesh = Mesh1D(1.0);\n\nif (mesh.dx - 1.0) > 1e-15\n    println(\"Incorrect x scale\")\nend\n\n# output\n\n\n\n\n\n\n","category":"type"},{"location":"public/#LFAToolkit.Mesh2D","page":"Public API","title":"LFAToolkit.Mesh2D","text":"Mesh2D()\n\nmesh = Mesh2D(1.0, 0.5);\n\nif (mesh.dx - 1.0) > 1e-15\n    println(\"Incorrect x scale\")\nend\nif (mesh.dy - 0.5) > 1e-15\n    println(\"Incorrect y scale\")\nend\n\n# output\n\n\n\n\n\n\n","category":"type"},{"location":"public/#LFAToolkit.Mesh3D","page":"Public API","title":"LFAToolkit.Mesh3D","text":"Mesh2D()\n\nmesh = Mesh3D(1.0, 0.5, 0.25);\n\nif (mesh.dx - 1.0) > 1e-15\n    println(\"Incorrect x scale\")\nend\nif (mesh.dy - 0.5) > 1e-15\n    println(\"Incorrect y scale\")\nend\nif (mesh.dz - 0.25) > 1e-15\n    printlt(\"Incorrect z scale\")\nend\n\n# output\n\n\n\n\n\n\n","category":"type"},{"location":"public/#Basis","page":"Public API","title":"Basis","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"TensorBasis\nNonTensorBasis\nTensorH1LagrangeBasis","category":"page"},{"location":"public/#LFAToolkit.TensorBasis","page":"Public API","title":"LFAToolkit.TensorBasis","text":"Tensor product basis\n\n\n\n\n\n","category":"type"},{"location":"public/#LFAToolkit.NonTensorBasis","page":"Public API","title":"LFAToolkit.NonTensorBasis","text":"Non-tensor basis\n\n\n\n\n\n","category":"type"},{"location":"public/#LFAToolkit.TensorH1LagrangeBasis","page":"Public API","title":"LFAToolkit.TensorH1LagrangeBasis","text":"TensorH1LagrangeBasis()\n\nTensor product basis on Gauss-Lobatto points with Gauss-Legendre quadrature\n\nbasis = TensorH1LagrangeBasis(4, 3, 2);\n\n# verify\nif basis.p1d != 4\n    println(\"Incorrect P1d\");\nend\nif basis.q1d != 3\n    println(\"Incorrect Q1d\");\nend\nif basis.dimension != 2\n    println(\"Incorrect dimension\");\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"public/#Basis-Evaluation-Mode","page":"Public API","title":"Basis Evaluation Mode","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"EvaluationMode.EvalMode","category":"page"},{"location":"public/#LFAToolkit.EvaluationMode.EvalMode","page":"Public API","title":"LFAToolkit.EvaluationMode.EvalMode","text":"Basis evaluation mode for operator inputs and outputs\n\nInterpolation - values interpolated to quadrature points\n\nGradient - derivatives evaluated at quadrature points\n\nQuadrature Weights - quadrature weights\n\nEvaluationMode.EvalMode\n\n# output\nEnum LFAToolkit.EvaluationMode.EvalMode:\ninterpolation = 0\ngradient = 1\nquadratureweights = 2\n\n\n\n\n\n","category":"type"},{"location":"public/#Operator-Field","page":"Public API","title":"Operator Field","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"OperatorField","category":"page"},{"location":"public/#LFAToolkit.OperatorField","page":"Public API","title":"LFAToolkit.OperatorField","text":"Finite Element operator input or output, with a basis and evaluation mode\n\n\n\n\n\n","category":"type"},{"location":"public/#Operator","page":"Public API","title":"Operator","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Operator","category":"page"},{"location":"public/#LFAToolkit.Operator","page":"Public API","title":"LFAToolkit.Operator","text":"Finite element operator comprising of a weak form and bases\n\n\n\n\n\n","category":"type"},{"location":"background/#Mathematical-Background","page":"Mathematical Background","title":"Mathematical Background","text":"","category":"section"},{"location":"#LFAToolkit","page":"Introduction","title":"LFAToolkit","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Local Fourier Analysis for arbitrary order finite element type operators","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Local Fourier Analysis is a tool commonly used in the analysis of multigrid and multilevel algorthms for solving partial differential equations via finite element or finite difference methods. This analysis can be used to predict convergance rates and optimize parameters in multilevel methods and preconditioners.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides a toolkit for analyzing the performance of preconditioners for arbitrary, user provided weak forms of partial differential equations.","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"background.md\",\n    \"public.md\",\n    \"private.md\",\n    \"references.md\"\n]","category":"page"}]
}
