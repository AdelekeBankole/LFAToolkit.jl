var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"A. Brandt, Multi-level adaptive solutions to boundary-value problems, Math. Comp., 31(138) (1977), pp33-390.","category":"page"},{"location":"references/","page":"References","title":"References","text":"J. Brown, Efficient nonlinear solvers for nodal high-order finite elements in 3D, Journal of Scientific Computing, 45 (2010), pp. 48-63.","category":"page"},{"location":"public/mesh/#Rectangular-Mesh","page":"Rectangular Mesh","title":"Rectangular Mesh","text":"","category":"section"},{"location":"public/mesh/","page":"Rectangular Mesh","title":"Rectangular Mesh","text":"Mesh1D\nMesh2D\nMesh3D","category":"page"},{"location":"public/mesh/#LFAToolkit.Mesh1D","page":"Rectangular Mesh","title":"LFAToolkit.Mesh1D","text":"Mesh1D(dx)\n\nOne dimensional regular background mesh\n\nArguments:\n\ndx: deformation in x dimension\n\nReturns:\n\nOne dimensional mesh object\n\nExample:\n\n# generate 1D mesh\nmesh = Mesh1D(1.0);\n\n# verify\nprintln(mesh)\n\n# output\n1d mesh:\n    dx: 1.0\n\n\n\n\n\n","category":"type"},{"location":"public/mesh/#LFAToolkit.Mesh2D","page":"Rectangular Mesh","title":"LFAToolkit.Mesh2D","text":"Mesh2D(dx, dy)\n\nTwo dimensional regular background mesh\n\nArguments:\n\ndx: deformation in x dimension\ndy: deformation in y dimension\n\nReturns:\n\nTwo dimensional mesh object\n\nExample:\n\n# generate 2D mesh\nmesh = Mesh2D(1.0, 0.5);\n\n# verify\nprintln(mesh)\n\n# output\n2d mesh:\n    dx: 1.0\n    dy: 0.5\n\n\n\n\n\n","category":"type"},{"location":"public/mesh/#LFAToolkit.Mesh3D","page":"Rectangular Mesh","title":"LFAToolkit.Mesh3D","text":"Mesh3D(dx, dy, dz)\n\nThree dimensional regular background mesh\n\nArguments:\n\ndx: deformation in x dimension\ndy: deformation in y dimension\ndz: deformation in z dimension\n\nReturns:\n\nThree dimensional mesh object\n\nExample:\n\n# generate 3D mesh\nmesh = Mesh3D(1.0, 0.5, 0.3);\n\n# verify\nprintln(mesh)\n\n# output\n3d mesh:\n    dx: 1.0\n    dy: 0.5\n    dz: 0.3\n\n\n\n\n\n","category":"type"},{"location":"private/pc_jacobi/#Preconditioner:-Jacobi","page":"Preconditioner: Jacobi","title":"Preconditioner: Jacobi","text":"","category":"section"},{"location":"private/pc_jacobi/","page":"Preconditioner: Jacobi","title":"Preconditioner: Jacobi","text":"LFAToolkit.getoperatordiagonalinverse","category":"page"},{"location":"private/pc_jacobi/#LFAToolkit.getoperatordiagonalinverse","page":"Preconditioner: Jacobi","title":"LFAToolkit.getoperatordiagonalinverse","text":"getoperatordiagonalinverse(preconditioner)\n\nCompute or retrieve the inverse of the symbol matrix diagonal for a Jacobi     preconditioner\n\nReturns:\n\nSymbol matrix diagonal inverse for the operator\n\nExample:\n\n# setup\nmesh = Mesh1D(1.0);\ndiffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n# preconditioner\njacobi = Jacobi(diffusion)\n\n# note: either syntax works\ndiagonalinverse = LFAToolkit.getoperatordiagonalinverse(jacobi);\ndiagonalinverse = jacobi.operatordiagonalinverse;\n\n# verify\n@assert diagonalinverse ≈ [3/14 0; 0 3/16]\n \n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/pc_pmultigrid/#Preconditioner:-P-Multigrid","page":"Preconditioner: P-Multigrid","title":"Preconditioner: P-Multigrid","text":"","category":"section"},{"location":"private/pc_pmultigrid/","page":"Preconditioner: P-Multigrid","title":"Preconditioner: P-Multigrid","text":"LFAToolkit.getnodecoordinatedifferences(::PMultigrid)\nLFAToolkit.getprolongationmatrix\nLFAToolkit.computesymbolspprolongation","category":"page"},{"location":"private/pc_pmultigrid/#LFAToolkit.getnodecoordinatedifferences-Tuple{PMultigrid}","page":"Preconditioner: P-Multigrid","title":"LFAToolkit.getnodecoordinatedifferences","text":"getnodecoordinateddifferences(multigrid)\n\nCompute or retrieve the array of differences in coordinates between nodes\n\nReturns:\n\nArray of differences in coordinates between nodes\n\n\n\n\n\n","category":"method"},{"location":"private/pc_pmultigrid/#LFAToolkit.getprolongationmatrix","page":"Preconditioner: P-Multigrid","title":"LFAToolkit.getprolongationmatrix","text":"getprolongationmatrix(multigrid)\n\nCompute or retrieve the prolongation matrix\n\nReturns:\n\nMatrix prolonging from coarse grid to fine grid\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nctofbasis = TensorH1LagrangeBasis(2, 3, 2, lagrangequadrature=true);\n\n# operators\nfinediffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\ncoarsediffusion = GalleryOperator(\"diffusion\", 2, 3, mesh);\n\n# smoother\njacobi = Jacobi(finediffusion);\n\n# preconditioner\nmultigrid = PMultigrid(finediffusion, coarsediffusion, jacobi, [ctofbasis]);\n\n# verify\nu = ones(ctofbasis.numbernodes);\nv = multigrid.prolongationmatrix * u;\n@assert transpose(v) ≈ [4. 2. 4. 2. 1. 2. 4. 2. 4.].^-1\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/pc_pmultigrid/#LFAToolkit.computesymbolspprolongation","page":"Preconditioner: P-Multigrid","title":"LFAToolkit.computesymbolspprolongation","text":"computesymbolspprolongation(multigrid, θ)\n\nCompute the symbol matrix for a p-multigrid prolongation operator\n\nArguments:\n\nmultigrid: P-multigrid operator to compute prolongation symbol matrix for\nθ:         Fourier mode frequency array (one frequency per dimension)\n\nReturns:\n\nSymbol matrix for the p-multigrid prolongation operator\n\n\n\n\n\n","category":"function"},{"location":"private/pc_base/#Preconditioner:-Abstract-Base-Class","page":"-","title":"Preconditioner: Abstract Base Class","text":"","category":"section"},{"location":"private/pc_base/","page":"-","title":"-","text":"LFAToolkit.AbstractPreconditioner","category":"page"},{"location":"private/pc_base/#LFAToolkit.AbstractPreconditioner","page":"-","title":"LFAToolkit.AbstractPreconditioner","text":"Finite element operator preconditioner \n\n\n\n\n\n","category":"type"},{"location":"private/basis/#Finite-Element-Basis","page":"Finite Element Basis","title":"Finite Element Basis","text":"","category":"section"},{"location":"private/basis/","page":"Finite Element Basis","title":"Finite Element Basis","text":"LFAToolkit.AbstractBasis\nLFAToolkit.gaussquadrature\nLFAToolkit.lobattoquadrature\nLFAToolkit.buildinterpolationandgradient\nLFAToolkit.getnumbernodes\nLFAToolkit.getnodes\nLFAToolkit.getnumberquadraturepoints\nLFAToolkit.getquadraturepoints\nLFAToolkit.getquadratureweights\nLFAToolkit.getinterpolation\nLFAToolkit.getgradient\nLFAToolkit.getnumbermodes\nLFAToolkit.getmodemap\nLFAToolkit.getdiagonal\nLFAToolkit.getdXdxgradient","category":"page"},{"location":"private/basis/#LFAToolkit.AbstractBasis","page":"Finite Element Basis","title":"LFAToolkit.AbstractBasis","text":"Finite element basis for function spaces and test spaces\n\n\n\n\n\n","category":"type"},{"location":"private/basis/#LFAToolkit.gaussquadrature","page":"Finite Element Basis","title":"LFAToolkit.gaussquadrature","text":"gaussquadrature(q)\n\nConstruct a Gauss-Legendre quadrature\n\nArguments:\n\nq: number of Gauss-Legendre points\n\nReturns:\n\nGauss-Legendre quadrature points and weights\n\nExample:\n\n# generate Gauss-Legendre points and weights\nquadraturepoints, quadratureweights = LFAToolkit.gaussquadrature(5);\n\n# verify\ntruepoints = [\n    -√(5 + 2*√(10/7))/3,\n    -√(5 - 2*√(10/7))/3,\n    0.0,\n    √(5 - 2*√(10/7))/3,\n    √(5 + 2*√(10/7))/3\n];\n@assert truepoints ≈ quadraturepoints\n\ntrueweights = [\n    (322-13*√70)/900,\n    (322+13*√70)/900,\n    128/225,\n    (322+13*√70)/900,\n    (322-13*√70)/900\n];\n@assert trueweights ≈ quadratureweights\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.lobattoquadrature","page":"Finite Element Basis","title":"LFAToolkit.lobattoquadrature","text":"lobattoquadrature(q, weights)\n\nConstruct a Gauss-Lobatto quadrature\n\nArguments:\n\nq:       number of Gauss-Lobatto points\nweights: boolean flag indicating if quadrature weights are desired\n\nReturns:\n\nGauss-Lobatto quadrature points or points and weights\n\nExample:\n\n# generate Gauss-Lobatto points\nquadraturepoints = LFAToolkit.lobattoquadrature(5, false);\n\n# verify\ntruepoints = [-1.0, -√(3/7), 0.0, √(3/7), 1.0];\n@assert truepoints ≈ quadraturepoints\n\n# generate Gauss-Lobatto points and weights\nquadraturepoints, quadratureweights = LFAToolkit.lobattoquadrature(5, true);\n\n# verify\ntrueweights = [1/10, 49/90, 32/45, 49/90, 1/10];\n@assert trueweights ≈ quadratureweights\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.buildinterpolationandgradient","page":"Finite Element Basis","title":"LFAToolkit.buildinterpolationandgradient","text":"buildinterpolationandgradient(\n    nodes,\n    quadraturepoints,\n)\n\nBuild one dimensional interpolation and gradient matrices, from Fornberg 1998\n\nArguments:\n\nnodes:            1d basis nodes\nquadraturepoints: 1d basis quadrature points\n\nReturns:\n\nOne dimensional interpolation and gradient matrices\n\nExample:\n\n# get nodes, quadrature points, and weights\nnumbernodes = 3;\nnumberquadraturepoints = 4;\nnodes = LFAToolkit.lobattoquadrature(numbernodes, false);\nquadraturepoints, quadratureweights1d = LFAToolkit.gaussquadrature(numberquadraturepoints);\n\n# build interpolation, gradient matrices\ninterpolation, gradient = LFAToolkit.buildinterpolationandgradient(nodes, quadraturepoints);\n\n# verify\nfor i in 1:numberquadraturepoints\n    total = sum(interpolation[i, :]);\n    @assert total ≈ 1.0\n\n    total = sum(gradient[i, :]);\n    @assert abs(total) < 1e-14\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getnumbernodes","page":"Finite Element Basis","title":"LFAToolkit.getnumbernodes","text":"getnumbernodes(basis)\n\nGet the number of nodes for the basis\n\nArguments:\n\nbasis: basis to compute number of nodes\n\nReturns:\n\nInteger number of basis nodes\n\nExample:\n\n# get number of nodes for basis\nbasis = TensorH1LagrangeBasis(4, 3, 2);\n\n# note: either syntax works\nnumbernodes = LFAToolkit.getnumbernodes(basis);\nnumbernodes = basis.numbernodes;\n\n# verify\n@assert numbernodes == 4^2\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getnodes","page":"Finite Element Basis","title":"LFAToolkit.getnodes","text":"getnodes(basis)\n\nGet nodes for basis\n\nReturns:\n\nBasis nodes array\n\nArguments:\n\nbasis: basis to compute nodes\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get basis quadrature weights\n    basis = TensorH1LagrangeBasis(4, 3, dimension);\n\n    # note: either syntax works\n    nodes = LFAToolkit.getnodes(basis);\n    nodes = basis.nodes;\n\n    # verify\n    truenodes1d = [-1, -√(1/5), √(1/5), 1];\n    truenodes = [];\n    if dimension == 1\n        truenodes = truenodes1d;\n    elseif dimension == 2\n        truenodes =\n            transpose(hcat([[[x, y] for x in truenodes1d, y in truenodes1d]...]...));\n    elseif dimension == 3\n        truenodes = transpose(hcat([[\n            [x, y, z] for x in truenodes1d, y in truenodes1d, z in truenodes1d\n        ]...]...));\n    end\n\n    @assert truenodes ≈ nodes\nend\n    \n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getnumberquadraturepoints","page":"Finite Element Basis","title":"LFAToolkit.getnumberquadraturepoints","text":"getnumberquadraturepoints(basis)\n\nGet the number of quadrature points for the basis\n\nArguments:\n\nbasis: basis to compute number of quadrature points\n\nReturns:\n\nInteger number of basis quadrature points\n\nExample:\n\n# get number of quadrature points for basis\nbasis = TensorH1LagrangeBasis(4, 3, 2);\n\n# note: either syntax works\nnumberquadraturepoints = LFAToolkit.getnumberquadraturepoints(basis);\nnumberquadraturepoints = basis.numberquadraturepoints;\n    \n# verify\n@assert numberquadraturepoints == 3^2\n    \n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getquadraturepoints","page":"Finite Element Basis","title":"LFAToolkit.getquadraturepoints","text":"getquadraturepoints(basis)\n\nGet quadrature points for basis\n\nReturns:\n\nBasis quadrature points array\n\nArguments:\n\nbasis: basis to compute quadrature points\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get basis quadrature weights\n    basis = TensorH1LagrangeBasis(4, 3, dimension);\n\n    # note: either syntax works\n    quadraturepoints = LFAToolkit.getquadraturepoints(basis);\n    quadraturepoints = basis.quadraturepoints;\n\n    # verify\n    truequadraturepoints1d = [-√(3/5), 0, √(3/5)];\n    truequadraturepoints = [];\n    if dimension == 1\n        truequadraturepoints = truequadraturepoints1d;\n    elseif dimension == 2\n        truequadraturepoints = transpose(hcat([[\n            [x, y] for x in truequadraturepoints1d, y in truequadraturepoints1d\n        ]...]...));\n    elseif dimension == 3\n        truequadraturepoints = transpose(hcat([[\n            [x, y, z]\n            for\n            x in truequadraturepoints1d,\n            y in truequadraturepoints1d, z in truequadraturepoints1d\n        ]...]...));\n    end\n\n    @assert truequadraturepoints ≈ quadraturepoints\nend\n    \n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getquadratureweights","page":"Finite Element Basis","title":"LFAToolkit.getquadratureweights","text":"getquadratureweights(basis)\n\nGet full quadrature weights vector for basis\n\nReturns:\n\nBasis quadrature weights vector\n\nArguments:\n\nbasis: basis to compute quadrature weights\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get basis quadrature weights\n    basis = TensorH1LagrangeBasis(4, 3, dimension);\n\n    # note: either syntax works\n    quadratureweights = LFAToolkit.getquadratureweights(basis);\n    quadratureweights = basis.quadratureweights;\n\n    # verify\n    trueweights1d = [5/9, 8/9, 5/9];\n    trueweights = [];\n    if dimension == 1\n        trueweights = trueweights1d;\n    elseif dimension == 2\n        trueweights = kron(trueweights1d, trueweights1d);\n    elseif dimension == 3\n        trueweights = kron(trueweights1d, trueweights1d, trueweights1d);\n    end\n\n    @assert trueweights ≈ quadratureweights\nend\n    \n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getinterpolation","page":"Finite Element Basis","title":"LFAToolkit.getinterpolation","text":"getinterpolation(basis)\n\nGet full interpolation matrix for basis\n\nArguments:\n\nbasis: basis to compute interpolation matrix\n\nReturns:\n\nBasis interpolation matrix\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get basis interpolation matrix\n    basis = TensorH1LagrangeBasis(4, 3, dimension);\n\n    # note: either syntax works\n    interpolation = LFAToolkit.getinterpolation(basis);\n    interpolation = basis.interpolation;\n\n    # verify\n    for i in 1:3^dimension\n        total = sum(interpolation[i, :]);\n        @assert total ≈ 1.0\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getgradient","page":"Finite Element Basis","title":"LFAToolkit.getgradient","text":"getgradient(basis)\n\nGet full gradient matrix for basis\n\nArguments:\n\nbasis: basis to compute gradient matrix\n\nReturns:\n\nBasis gradient matrix\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get basis gradient matrix\n    basis = TensorH1LagrangeBasis(4, 3, dimension);\n\n    # note: either syntax works\n    gradient = LFAToolkit.getgradient(basis);\n    gradient = basis.gradient;\n\n    # verify\n    for i in 1:dimension*3^dimension\n        total = sum(gradient[i, :]);\n        @assert abs(total) < 1e-14\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getnumbermodes","page":"Finite Element Basis","title":"LFAToolkit.getnumbermodes","text":"getnumbermodes(basis)\n\nGet number of modes for basis\n\nArguments:\n\nbasis: basis to compute number of modes\n\nReturns:\n\nNumber of modes for basis\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get number of basis modes\n    basis = TensorH1LagrangeBasis(4, 3, dimension);\n\n    # note: either syntax works\n    numbermodes = LFAToolkit.getnumbermodes(basis);\n    numbermodes = basis.numbermodes;\n\n    # verify\n    @assert numbermodes == 3^dimension\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getmodemap","page":"Finite Element Basis","title":"LFAToolkit.getmodemap","text":"getmodemap(basis)\n\nGet mode mapping vector for basis\n\nArguments:\n\nbasis: basis to compute mode map vector\n\nReturns:\n\nBasis mode map vector\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get mode map vector\n    basis = TensorH1LagrangeBasis(4, 3, dimension);\n\n    # note: either syntax works\n    modemap = LFAToolkit.getmodemap(basis);\n    modemap = basis.modemap;\n\n    # verify\n    truemodemap1d = [1, 2, 3, 1];\n    truemodemap = [];\n    if dimension == 1\n        truemodemap = truemodemap1d;\n    elseif dimension == 2\n        truemodemap = [[\n            i + (j - 1)*3 for i in truemodemap1d, j in truemodemap1d\n        ]...];\n    elseif dimension == 3\n        truemodemap = [[\n            i +\n            (j - 1)*3 +\n            (k - 1)*3^2\n            for i in truemodemap1d, j in truemodemap1d, k in truemodemap1d\n        ]...];\n    end\n\n    @assert truemodemap == modemap\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getdiagonal","page":"Finite Element Basis","title":"LFAToolkit.getdiagonal","text":"getdiagonal(operator)\n\nCompute or retrieve the symbol matrix diagonal for an operator\n\nReturns:\n\nSymbol matrix diagonal for the operator\n\nExample:\n\n# setup\nmesh = Mesh1D(1.0);\ndiffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n# note: either syntax works\ndiagonal = LFAToolkit.getdiagonal(diffusion);\ndiagonal = diffusion.diagonal;\n\n# verify\n@assert diagonal ≈ [14/3 0; 0 16/3]\n \n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getdXdxgradient","page":"Finite Element Basis","title":"LFAToolkit.getdXdxgradient","text":"getdXdxgradient(basis, mesh)\n\nGet gradient adjusted for mesh stretching\n\nArguments:\n\nbasis: basis to compute gradient\nmesh:  mesh to compute gradient\n\nReturns:\n\ngradient matrix multiplied by change of coordinates adjoint\n\nExample:\n\nfor dimension in 1:3\n    # mesh\n    mesh = []\n    if dimension == 1\n        mesh = Mesh1D(2.0)\n    elseif dimension == 2\n        mesh = Mesh2D(2.0, 3.0)\n    elseif dimension == 3\n        mesh = Mesh3D(2.0, 3.0, 4.0)\n    end\n\n    # basis\n    basis = TensorH1LagrangeBasis(4, 3, dimension);\n\n    # get gradient on mesh\n    gradient = LFAToolkit.getdXdxgradient(basis, mesh);\n\n    # verify\n    nodes = basis.nodes;\n    linearfunction = [];\n    truegradient = [];\n    if dimension == 1\n        linearfunction = nodes/2;\n        truegradient = [1/2*ones(basis.numberquadraturepoints)...]\n    elseif dimension == 2\n        linearfunction = (nodes[:, 1] + nodes[:, 2])/2;\n        truegradient = [\n            1/2*ones(basis.numberquadraturepoints)...\n            1/3*ones(basis.numberquadraturepoints)...\n        ]\n    elseif dimension == 3\n        linearfunction = (nodes[:, 1] + nodes[:, 2] + nodes[:, 3])/2;\n        truegradient = [\n            1/2*ones(basis.numberquadraturepoints)...\n            1/3*ones(basis.numberquadraturepoints)...\n            1/4*ones(basis.numberquadraturepoints)...\n        ]\n    end\n\n    @assert gradient*linearfunction ≈ truegradient\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/#Private-API","page":"Overview","title":"Private API","text":"","category":"section"},{"location":"private/","page":"Overview","title":"Overview","text":"This section documents the private API of the LFAToolkit.","category":"page"},{"location":"private/#Contents","page":"Overview","title":"Contents","text":"","category":"section"},{"location":"private/","page":"Overview","title":"Overview","text":"Pages = [\n    \"private/mesh.md\",\n    \"private/basis.md\",\n    \"private/operator.md\",\n    \"private/pc_base.md\",\n    \"private/pc_jacobi.md\",\n    \"private/pc_pmultigrid.md\",\n]","category":"page"},{"location":"public/pc_jacobi/#Preconditioner:-Jacobi","page":"Preconditioner: Jacobi","title":"Preconditioner: Jacobi","text":"","category":"section"},{"location":"public/pc_jacobi/#Example","page":"Preconditioner: Jacobi","title":"Example","text":"","category":"section"},{"location":"public/pc_jacobi/","page":"Preconditioner: Jacobi","title":"Preconditioner: Jacobi","text":"This is an example of a simple Jacobi smoother.","category":"page"},{"location":"public/pc_jacobi/","page":"Preconditioner: Jacobi","title":"Preconditioner: Jacobi","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex3_jacobi.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/pc_jacobi/#Documentation","page":"Preconditioner: Jacobi","title":"Documentation","text":"","category":"section"},{"location":"public/pc_jacobi/","page":"Preconditioner: Jacobi","title":"Preconditioner: Jacobi","text":"Jacobi\ncomputesymbols(::Jacobi, ::Array, ::Array)","category":"page"},{"location":"public/pc_jacobi/#LFAToolkit.Jacobi","page":"Preconditioner: Jacobi","title":"LFAToolkit.Jacobi","text":"Jacobi(operator)\n\nJacobi diagonal preconditioner for finite element operators\n\nArguments:\n\noperator: finite element operator to precondition\n\nReturns:\n\nJacobi preconditioner object\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# preconditioner\njacobi = Jacobi(mass);\n\n# verify\nprintln(jacobi)\nprintln(jacobi.operator)\n\n# output\njacobi preconditioner\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    dimension: 2\n  evaluation mode:\n    interpolation\noperator field:\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    dimension: 2\n  evaluation mode:\n    interpolation\n\n\n\n\n\n","category":"type"},{"location":"public/pc_jacobi/#LFAToolkit.computesymbols-Tuple{Jacobi,Array,Array}","page":"Preconditioner: Jacobi","title":"LFAToolkit.computesymbols","text":"computesymbols(preconditioner, ω, θ)\n\nCompute or retrieve the symbol matrix for a Jacobi preconditioned operator\n\nArguments:\n\npreconditioner: Jacobi preconditioner to compute symbol matrix for\nω:              Smoothing weighting factor array\nθ:              Fourier mode frequency array (one frequency per dimension)\n\nReturns:\n\nSymbol matrix for the Jacobi preconditioned operator\n\nExample:\n\nusing LinearAlgebra\n\nfor dimension in 1:3\n    # setup\n    mesh = []\n    if dimension == 1\n        mesh = Mesh1D(1.0);\n    elseif dimension == 2\n        mesh = Mesh2D(1.0, 1.0);\n    elseif dimension == 3\n        mesh = Mesh3D(1.0, 1.0, 1.0);\n    end\n    diffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n    # preconditioner\n    jacobi = Jacobi(diffusion);\n\n    # compute symbols\n    A = computesymbols(jacobi, [1.0], π*ones(dimension));\n\n    # verify\n    using LinearAlgebra;\n    eigenvalues = real(eigvals(A));\n    if dimension == 1\n        @assert max(eigenvalues...) ≈ 1/7\n    elseif dimension == 2\n        @assert min(eigenvalues...) ≈ -1/14\n    elseif dimension == 3\n        @assert min(eigenvalues...) ≈ -0.33928571428571486\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"private/operator/#Finite-Element-Operator","page":"Finite Element Operator","title":"Finite Element Operator","text":"","category":"section"},{"location":"private/operator/","page":"Finite Element Operator","title":"Finite Element Operator","text":"LFAToolkit.massoperator\nLFAToolkit.diffusionoperator\nLFAToolkit.getelementmatrix\nLFAToolkit.getmultiplicity\nLFAToolkit.getrowmodemap\nLFAToolkit.getcolumnmodemap\nLFAToolkit.getinputcoordinates\nLFAToolkit.getoutputcoordinates\nLFAToolkit.getnodecoordinatedifferences(::Operator)","category":"page"},{"location":"private/operator/#LFAToolkit.massoperator","page":"Finite Element Operator","title":"LFAToolkit.massoperator","text":"Operator(\"mass\", p, mesh)\n\nConvenience constructor for scalar mass operator\n\nArguments:\n\np1d:  polynomial order of TensorH1LagrangeBasis\nq1d:  number of quadrature points in one dimension for basis\nmesh: mesh for operator\n\nReturns:\n\nMass matrix operator of order p on mesh\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.diffusionoperator","page":"Finite Element Operator","title":"LFAToolkit.diffusionoperator","text":"Operator(\"diffusion\", p, mesh)\n\nConvenience constructor for scalar diffusion operator\n\nArguments:\n\np1d:  polynomial order of TensorH1LagrangeBasis\nq1d:  number of quadrature points in one dimension for basis\nmesh: mesh for operator\n\nReturns:\n\nDiffusion operator of order p on mesh\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.getelementmatrix","page":"Finite Element Operator","title":"LFAToolkit.getelementmatrix","text":"getelementmatrix(operator)\n\nCompute or retrieve the element matrix of operator for computing the symbol\n\nArguments:\n\noperator: operator to compute element element matrix\n\nReturns:\n\nAssembled element matrix\n\nMass matrix example:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n    \n# element matrix computation\n# note: either syntax works\nelementmatrix = LFAToolkit.getelementmatrix(mass);\nelementmatrix = mass.elementmatrix;\n\n# verify\nu = ones(4*4);\nv = elementmatrix*u;\n    \ntotal = sum(v);\n@assert total ≈ 1.0\n    \n# output\n\n\nDiffusion matrix example:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\ndiffusion = GalleryOperator(\"diffusion\", 4, 4, mesh);\n    \n# element matrix computation\n# note: either syntax works\nelementmatrix = LFAToolkit.getelementmatrix(diffusion);\nelementmatrix = diffusion.elementmatrix;\n    \n# verify\nu = ones(4*4);\nv = elementmatrix*u;\n    \ntotal = sum(v);\n@assert abs(total) < 1e-14\n    \n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.getmultiplicity","page":"Finite Element Operator","title":"LFAToolkit.getmultiplicity","text":"getmultiplicity(operator)\n\nCompute or retrieve the vector of node multiplicity for the operator\n\nReturns:\n\nVector of node multiplicity for the operator\n\nExample\n\n```jldoctest for dimension in 1:3     # setup     mesh = []     if dimension == 1         mesh = Mesh1D(1.0);     elseif dimension == 2         mesh = Mesh2D(1.0, 1.0);     elseif dimension == 3         mesh = Mesh3D(1.0, 1.0, 1.0);     end     diffusion = GalleryOperator(\"diffusion\", 5, 5, mesh);\n\n# compute multiplicity\nmult = diffusion.multiplicity;\n\n# verify\nmult1D = [2. 1. 1. 1. 2.];\nif dimension == 1\n    @assert mult ≈ mult1D\nelseif dimension == 2\n    @assert mult ≈ kron(mult1D, mult1D)\nelseif dimension == 3\n    @assert mult ≈ kron(mult1D, mult1D, mult1D)\nend\n\nend\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.getrowmodemap","page":"Finite Element Operator","title":"LFAToolkit.getrowmodemap","text":"getrowmodemap(operator)\n\nCompute or retrieve the matrix mapping the rows of the element matrix to the symbol matrix\n\nReturns:\n\nMatrix mapping rows of element matrix to symbol matrix\n\nExample:\n\n# setup\nmesh = Mesh1D(1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# note: either syntax works\nmodemap = LFAToolkit.getrowmodemap(mass);\nmodemap = mass.rowmodemap;\n\n# verify\n@assert modemap ≈ [1 0 0 1; 0 1 0 0; 0 0 1 0]\n    \n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.getcolumnmodemap","page":"Finite Element Operator","title":"LFAToolkit.getcolumnmodemap","text":"getcolumnmodemap(operator)\n\nCompute or retrieve the matrix mapping the columns of the element matrix to the   symbol matrix\n\nReturns:\n\nMatrix mapping columns of element matrix to symbol matrix\n\nExample:\n\n# setup\nmesh = Mesh1D(1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# note: either syntax works\nmodemap = LFAToolkit.getcolumnmodemap(mass);\nmodemap = mass.columnmodemap;\n\n# verify\n@assert modemap ≈ [1 0 0; 0 1 0; 0 0 1; 1 0 0]\n    \n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.getinputcoordinates","page":"Finite Element Operator","title":"LFAToolkit.getinputcoordinates","text":"getinputcoordinates(operator)\n\nCompute or retrieve the array of input coordinates\n\nReturns:\n\nArray of input coordinates\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.getoutputcoordinates","page":"Finite Element Operator","title":"LFAToolkit.getoutputcoordinates","text":"getoutputcoordinates(operator)\n\nCompute or retrieve the array of output coordinates\n\nReturns:\n\nArray of output coordinates\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.getnodecoordinatedifferences-Tuple{Operator}","page":"Finite Element Operator","title":"LFAToolkit.getnodecoordinatedifferences","text":"getnodecoordinatedifferences(operator)\n\nCompute or retrieve the array of differences in coordinates between nodes\n\nReturns:\n\nArray of differences in coordinates between nodes\n\nExample:\n\n# setup\nmesh = Mesh1D(1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# note: either syntax works\nnodedifferences = LFAToolkit.getnodecoordinatedifferences(mass);\nnodedifferences = mass.nodecoordinatedifferences;\n\n# verify\ntruenodes = LFAToolkit.lobattoquadrature(4, false);\ntruenodedifferences = [\n    (truenodes[j] - truenodes[i])/2.0 for i in 1:4, j in 1:4\n];\n@assert nodedifferences ≈ truenodedifferences\n \n# output\n\n\n\n\n\n\n","category":"method"},{"location":"public/basis/#Finite-Element-Basis","page":"Finite Element Basis","title":"Finite Element Basis","text":"","category":"section"},{"location":"public/basis/","page":"Finite Element Basis","title":"Finite Element Basis","text":"TensorBasis\nNonTensorBasis\nTensorH1LagrangeBasis\nTensorH1UniformBasis","category":"page"},{"location":"public/basis/#LFAToolkit.TensorBasis","page":"Finite Element Basis","title":"LFAToolkit.TensorBasis","text":"TensorBasis(\n    numbernodes1d,\n    numberquadraturepoints1d,\n    dimension,\n    nodes1d,\n    quadraturepoints1d,\n    quadratureweights1d,\n    interpolation1d,\n    gradient1d\n)\n\nTensor product basis\n\nArguments:\n\nnumbernodes1d:            number of nodes in 1 dimension\nnumberquadraturepoints1d: number of quadrature points in 1 dimension\ndimension:                dimension of the basis\nnodes1d:                  coordinates of the nodes in 1 dimension\nquadraturepoints1d:       coordinates of the quadrature points in 1                                 dimension\nquadratureweights1d:      quadrature weights in 1 dimension\ninterpolation1d:          interpolation matrix from nodes to quadrature                                 points in 1 dimension\ngradient1d:               gradient matrix from nodes to quadrature points in                                 1 dimension\n\nReturns:\n\nTensor product basis object\n\n\n\n\n\n","category":"type"},{"location":"public/basis/#LFAToolkit.NonTensorBasis","page":"Finite Element Basis","title":"LFAToolkit.NonTensorBasis","text":"NonTensorBasis(\n    numbernodes,\n    numberquadraturepoints,\n    dimension,\n    nodes,\n    quadraturepoints,\n    quadratureweights,\n    interpolation,\n    gradient\n)\n\nNon-tensor basis\n\nArguments:\n\nnumbernodes:            number of nodes \nnumberquadraturepoints: number of quadrature points\ndimension:              dimension of the basis\nnodes:                  coordinates of the nodes\nquadraturepoints:       coordinates of the quadrature points\nquadratureweights:      quadrature weights\ninterpolation:          interpolation matrix from nodes to quadrature points\ngradient:               gradient matrix from nodes to quadrature points\n\nReturns:\n\nNon-tensor product basis object\n\n\n\n\n\n","category":"type"},{"location":"public/basis/#LFAToolkit.TensorH1LagrangeBasis","page":"Finite Element Basis","title":"LFAToolkit.TensorH1LagrangeBasis","text":"TensorH1LagrangeBasis(\n    numbernodes1d,\n    numberquadraturepoints1d,\n    dimension,\n    lagrangequadrature,\n)\n\nTensor product basis on Gauss-Lobatto points with Gauss-Legendre quadrature\n\nArguments:\n\nnumbernodes1d:            number of Gauss-Lobatto nodes\nnumberquadraturepoints1d: number of Gauss-Legendre quadrature points\ndimension:                dimension of basis\nlagrangequadrature=false: Gauss-Lagrange or Gauss-Lobatto quadrature points,                                 default: Gauss-Lobatto\n\nReturns:\n\nH1 Lagrange tensor product basis object\n\nExample:\n\n# generate H1 Lagrange tensor product basis\nbasis = TensorH1LagrangeBasis(4, 4, 2);\n\n# generate basis with Lagrange quadrature points\nbasis = TensorH1LagrangeBasis(4, 4, 2, lagrangequadrature=true);\n\n# verify\nprintln(basis)\n\n# output\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    dimension: 2\n\n\n\n\n\n","category":"function"},{"location":"public/basis/#LFAToolkit.TensorH1UniformBasis","page":"Finite Element Basis","title":"LFAToolkit.TensorH1UniformBasis","text":"TensorH1UniformBasis(\n    numbernodes1d,\n    numberquadraturepoints1d,\n    dimension,\n)\n\nTensor product basis on uniformly points with Gauss-Legendre quadrature\n\nArguments:\n\nnumbernodes1d:            number of uniformly spaced nodes\nnumberquadraturepoints1d: number of Gauss-Legendre quadrature points\ndimension:                dimension of basis\n\nReturns:\n\nH1 uniformly spaced tensor product basis object\n\nExample:\n\n# generate H1 uniformly spaced tensor product basis\nbasis = TensorH1UniformBasis(4, 3, 2);\n\n# verify\nprintln(basis)\n\n# output\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 3\n    dimension: 2\n\n\n\n\n\n","category":"function"},{"location":"public/operatorfield/#Operator-Field","page":"Operator Field","title":"Operator Field","text":"","category":"section"},{"location":"public/operatorfield/","page":"Operator Field","title":"Operator Field","text":"OperatorField","category":"page"},{"location":"public/operatorfield/#LFAToolkit.OperatorField","page":"Operator Field","title":"LFAToolkit.OperatorField","text":"OperatorField(\n    basis,\n    evaluationmodes\n)\n\nFinite Element operator input or output, with a basis and evaluation mode\n\nArguments:\n\nbasis:           finite element basis for the field\nevaluationmodes: array of basis evaluation modes,                        note that quadrature weights must be listed in a                        separate operator field\n\nReturns:\n\nFinite element operator field object\n\nExample:\n\n# basis\nbasis = TensorH1LagrangeBasis(4, 3, 2);\n\n# quadrature weights field\nweightsfield = OperatorField(basis, [EvaluationMode.quadratureweights]);\n\n# verify\nprintln(weightsfield)\n\n# input or output field\ninputfield = OperatorField(basis, [\n    EvaluationMode.interpolation,\n    EvaluationMode.gradient,\n]);\n\n# verify\nprintln(inputfield)\n\n# output\noperator field:\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 3\n    dimension: 2\n  evaluation mode:\n    quadratureweights\noperator field:\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 3\n    dimension: 2\n  evaluation modes:\n    interpolation\n    gradient\n\n\n\n\n\n","category":"type"},{"location":"public/operator/#Finite-Element-Operator","page":"Finite Element Operator","title":"Finite Element Operator","text":"","category":"section"},{"location":"public/operator/#Examples","page":"Finite Element Operator","title":"Examples","text":"","category":"section"},{"location":"public/operator/","page":"Finite Element Operator","title":"Finite Element Operator","text":"This is an example of a simple mass operator in two dimensions.","category":"page"},{"location":"public/operator/","page":"Finite Element Operator","title":"Finite Element Operator","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex1_mass.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/operator/","page":"Finite Element Operator","title":"Finite Element Operator","text":"This is an example of a simple diffusion operator in two dimensions.","category":"page"},{"location":"public/operator/","page":"Finite Element Operator","title":"Finite Element Operator","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex2_diffusion.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/operator/#Documentation","page":"Finite Element Operator","title":"Documentation","text":"","category":"section"},{"location":"public/operator/","page":"Finite Element Operator","title":"Finite Element Operator","text":"Operator\nGalleryOperator\ncomputesymbols(::Operator, ::Array)","category":"page"},{"location":"public/operator/#LFAToolkit.Operator","page":"Finite Element Operator","title":"LFAToolkit.Operator","text":"Operator(\n    weakform,\n    mesh,\n    inputs,\n    outputs\n)\n\nFinite element operator comprising of a weak form and bases\n\nArguments:\n\nweakform: user provided function that represents weak form at                 quadrature points\nmesh:     mesh object with deformation in each dimension\ninputs:   array of operator input fields\noutputs:  array of operator output fields\n\nReturns:\n\nFinite element operator object\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nbasis = TensorH1LagrangeBasis(4, 4, 2);\n    \nfunction massweakform(u::Array{Float64}, w::Array{Float64})\n    v = u*w[1]\n    return [v]\nend\n    \n# mass operator\ninputs = [\n    OperatorField(basis, [EvaluationMode.interpolation]),\n    OperatorField(basis, [EvaluationMode.quadratureweights]),\n];\noutputs = [OperatorField(basis, [EvaluationMode.interpolation])];\nmass = Operator(massweakform, mesh, inputs, outputs);\n\n# verify\nprintln(mass)\n\n# output\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    dimension: 2\n  evaluation mode:\n    interpolation\noperator field:\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    dimension: 2\n  evaluation mode:\n    interpolation\n\n\n\n\n\n","category":"type"},{"location":"public/operator/#LFAToolkit.GalleryOperator","page":"Finite Element Operator","title":"LFAToolkit.GalleryOperator","text":"GalleryOperator(name, p1d, q1d, mesh)\n\nFinite element operator from a gallery of options\n\nArguments:\n\nname: string containing name of operator\np1d:  polynomial order of TensorH1LagrangeBasis\nq1d:  number of quadrature points in one dimension for basis\nmesh: mesh for operator\n\nReturns:\n\nFinite element operator object\n\nMass matrix example:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# verify\nprintln(mass)\n\n# output\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    dimension: 2\n  evaluation mode:\n    interpolation\noperator field:\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    dimension: 2\n  evaluation mode:\n    interpolation\n\nDiffusion operator example:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\ndiffusion = GalleryOperator(\"diffusion\", 4, 4, mesh);\n\n# verify\nprintln(diffusion)\n\n# output\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    dimension: 2\n  evaluation mode:\n    gradient\noperator field:\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    dimension: 2\n  evaluation mode:\n    gradient\n\n\n\n\n\n","category":"function"},{"location":"public/operator/#LFAToolkit.computesymbols-Tuple{Operator,Array}","page":"Finite Element Operator","title":"LFAToolkit.computesymbols","text":"computesymbols(operator, θ)\n\nCompute the symbol matrix for an operator\n\nArguments:\n\noperator: Finite element operator to compute symbol matrix for\nθ:              Fourier mode frequency array (one frequency per dimension)\n\nReturns:\n\nSymbol matrix for the operator\n\nExample:\n\nusing LinearAlgebra;\n\nfor dimension in 1:3\n    # setup\n    mesh = []\n    if dimension == 1\n        mesh = Mesh1D(1.0);\n    elseif dimension == 2\n        mesh = Mesh2D(1.0, 1.0);\n    elseif dimension == 3\n        mesh = Mesh3D(1.0, 1.0, 1.0);\n    end\n    diffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n    # compute symbols\n    A = computesymbols(diffusion, π*ones(dimension));\n\n    # verify\n    eigenvalues = real(eigvals(A));\n    if dimension == 1\n        @assert min(eigenvalues...) ≈ 4\n        @assert max(eigenvalues...) ≈ 16/3\n    elseif dimension == 2\n        @assert min(eigenvalues...) ≈ 8/3\n        @assert max(eigenvalues...) ≈ 256/45\n    elseif dimension == 3\n        @assert min(eigenvalues...) ≈ 4/3\n        @assert max(eigenvalues...) ≈ 1024/225\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"public/evaluationmode/#Basis-Evaluation-Mode","page":"Basis Evaluation Mode","title":"Basis Evaluation Mode","text":"","category":"section"},{"location":"public/evaluationmode/","page":"Basis Evaluation Mode","title":"Basis Evaluation Mode","text":"EvaluationMode.EvalMode","category":"page"},{"location":"public/evaluationmode/#LFAToolkit.EvaluationMode.EvalMode","page":"Basis Evaluation Mode","title":"LFAToolkit.EvaluationMode.EvalMode","text":"Basis evaluation mode for operator inputs and outputs\n\nModes:\n\ninterpolation:     values interpolated to quadrature points\ngradient:          derivatives evaluated at quadrature points\nquadratureweights: quadrature weights\n\nExample:\n\nEvaluationMode.EvalMode\n\n# output\nEnum LFAToolkit.EvaluationMode.EvalMode:\ninterpolation = 0\ngradient = 1\nquadratureweights = 2\n\n\n\n\n\n","category":"type"},{"location":"public/#Public-API","page":"Overview","title":"Public API","text":"","category":"section"},{"location":"public/","page":"Overview","title":"Overview","text":"This section documents the public API of the LFAToolkit.","category":"page"},{"location":"public/#Contents","page":"Overview","title":"Contents","text":"","category":"section"},{"location":"public/","page":"Overview","title":"Overview","text":"Pages = [\n    \"public/mesh.md\",\n    \"public/basis.md\",\n    \"public/evaluationmode.md\",\n    \"public/operatorfield.md\",\n    \"public/operator.md\",\n    \"public/pc_jacobi.md\",\n    \"public/pc_pmultigrid.md\",\n]","category":"page"},{"location":"background/#Mathematical-Background","page":"Mathematical Background","title":"Mathematical Background","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Local Fourier Analysis was first used by Brandt [1] to analyze the convergence of multi-level adaptive techniques for solving PDEs discretized with finite differences, but the technique has been adapted for multi-level and multi-grid techniques using finite element discretizations.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"By way of example, we will explore Local Fourier Analysis for multilevel and mutligrid methods for the two dimensional Poisson problem, given by the PDE","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"- nabla^2 u = f","category":"page"},{"location":"background/#Local-Fourier-Modes","page":"Mathematical Background","title":"Local Fourier Modes","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Local Fourier Analysis considers the local properties of the descretized system via its Fourier modes and the eigenvalues of the associated symbol matrix. We will describe the simple one dimensional scalar case and extend it to an arbitrary dimension, degree, and component finite element problem.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"First consider a scalar Toeplitz operator L_h on a one dimensional infinite uniform grid G_h. This operator is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"L_h mathrelhat= left s_kappa right_h left( kappa in V right)\n\nL_h w_h left( x right) = sum_kappa in V s_kappa w_h left( x + kappa h right)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where V subset mathcalZ is a finite index set, s_kappa in mathcalR are constant coefficients, and w_h left( x right) is a l^2 function on G_h.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"As L_h is Toeplitz, it can be diagonalized by the standard Fourier modes varphi left( theta x right) = e^imath theta x  h.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"If for all grid functions varphi left( theta x right) we have","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"L_h varphi left( theta x right) = tildeL_h left( theta right) varphi left( theta x right)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"then tildeL_h left( theta right) = sum_kappa in V s_kappa e^imath theta kappa is the symbol of L_h.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"We can extend this to a p times p linear system of operators representing a scalar problem on a p order finite element","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeL_h =\nbeginbmatrix\n    tildeL_h^1 1    cdots    tildeL_h^1 p \n    vdots                vdots    vdots             \n    tildeL_h^p 1    cdots    tildeL_h^p p \nendbmatrix","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where tildeL_h^i j is given by a scalar Toeplitz operator describing how component j appears in the equation for component i.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Consider the specific case of the Topeliz operator representing the scalar diffusion operator. The Poisson problem has the weak formulation","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"int_Omega nabla u cdot nabla v - int_partial Omega nabla u v = int_Omega f v forall v in V","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"for some suitable V subseteq H_0^1 left( Omega right).","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Selecting a finite element basis, we can discretize the weak form and produce","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"A u = b","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Using the algebraic representation of PDE operators discussed in [2], the assembled matrix is of the form","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"A = P^T A_e P","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"A_e = B^T D B","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where P represents the element assembly operator, B represents computing the derivatives of the basis functions at the quadrature points, and D represents a pointwise application of the bilinear form with quadrature weights, to include a change of coordinates to the reference space. As we are on the infinite grid, G_h, boundary conditions have been omitted. This analysis will also be equivalent to periodic boundary conditions.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"With a nodal basis of order p, the nodes on the boundary of the element are equivalent, and we can thus compute the symbol matrix as","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeA_h = Q^T left( A_e odot\nbeginbmatrix\n    e^imath left( x_0 - x_0 right) theta          cdots    e^imath left( x_0 - x_p + 1 right) theta        \n    vdots                                              vdots    vdots                                                  \n    e^imath left( x_p + 1 - x_0 right) theta    cdots    e^imath left( x_p + 1 - x_p + 1 right) theta  \nendbmatrix\nright) Q","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where odot represents pointwise multiplication of the elements and","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Q =\nbeginbmatrix\n    1         0         cdots    0         1       \n    0         1         cdots    0         0       \n    vdots    vdots    vdots    vdots    vdots  \n    0         0         cdots    1         0       \nendbmatrix","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"maps the equivalent basis nodes to the same Fourier mode.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"This same computation of the symbol matrix extends to more complex PDE with multiple components and in higher dimensions.","category":"page"},{"location":"background/#Multigrid","page":"Mathematical Background","title":"Multigrid","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Multigrid follows the following algorithm:","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"pre-smooth   : u_i = u_i + M^-1 left( b - A u_i right)\nrestrict     : r_c = R_ftoc left( b - A u_i right)\ncoarse solve : A_c e_c = r_c\nprolongate   : u_i = u_i + P_ctof e_c\npost-smooth  : u_i = u_i + M^-1 left( b - A u_i right)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where f and c represent the fine and coarse grids, respectively, R_ftoc represents the grid restriction operator, P_ctof represents the grid prolongation operator.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"To explore the convergence of multigrid techniques, we need to analyze the symbol of the multigrid error propagation operator","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"E_f left( p theta right) = S_h left( p theta right) E_c left( theta right) S_h left( p theta right)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"The symbol of the coarse grid error propagation operator is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"E_c left( theta right) = I - tildeP_ctof left( theta right) tildeA_c^-1 left( theta right) tildeR_ftoc left( theta right) tildeA_f left( theta right)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"The spectral radius of the symbol of the error propagation operator determines how rapidly a relaxation scheme decreases error at a target frequency for a given parameter value. In a multigrid technique, the purpose of the smoothing operator is to reduce the higher frequency components of the error, where low frequencies are given by theta in T^low = left - fracpip fracpip right) and high frequencies are given by theta in T^high = left - fracpip fracleft( 2 p - 1 right) pip right) setminus T^low.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"We build the symbol of the multigrid error propagation operator in parts.","category":"page"},{"location":"background/#Smoothing-Operator","page":"Mathematical Background","title":"Smoothing Operator","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Multigrid techniques require error relaxation techniques. The error propagation operator for a relaxation technique is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"S = I - M^-1 A","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"In the specific case of Jacobi smoothing, M is given by M = diag left( A right).","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"The symbol of the error propagation operator is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"S_h left( omega theta right) = I - tildeM_h^-1 tildeA_h left( theta right)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where omega is a relaxation parameter.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Specifically, for Jacobi we have","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"S_h left( omega theta right) = I - omega tildeM_h^-1 tildeA_h left( theta right)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where omega is the weighting factor and tildeM_h is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeM_h = Q^T left( diag left( A_e right) odot\nbeginbmatrix\n    e^imath left( x_0 - x_0 right) theta          cdots    e^imath left( x_0 - x_p + 1 right) theta        \n    vdots                                              vdots    vdots                                                  \n    e^imath left( x_p + 1 - x_0 right) theta    cdots    e^imath left( x_p + 1 - x_p + 1 right) theta  \nendbmatrix\nright) Q","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"If multiple pre or post-smoothing passes are used, we have","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"S_h left( omega nu theta right) = left( I - omega tildeM_h^-1 tildeA_h left( theta right) right)^nu","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where nu is the number of smoothing passes.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"User defined smoothers are supported, where the user provides M^-1 or a function derive it based upon A, and tildeM^-1_h and S_h are automatically generated.","category":"page"},{"location":"background/#Grid-Transfer-Operators","page":"Mathematical Background","title":"Grid Transfer Operators","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"We consider grid transfer operators for p-type multigrid. Prolongation from the lower order coarse grid to the high order fine grid is given by ","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"P_ctof = P_fine^T D_scale B_c to f P_coarse","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where B_c to f is a basis interpolation from the coarse basis to the fine basis, P_f is the fine grid element assembly operator, P_c is the coarse grid element assembly operator, and D_scale is a scaling for node multiplicity across element interfaces.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Restriction from the fine grid to the coarse grid is given by the transpose, R_ftoc = P_ctof^T.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Thus, the symbol of P_ctof is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeP_ctof left( theta right) = Q_f^T left( left( D_scale B_ctof right) odot\nbeginbmatrix\n    e^imath left( x_0 f - x_0 c right) theta          cdots    e^imath left( x_0 f - x_p_c + 1 c right) theta        \n    vdots                                                        vdots    vdots                                                            \n    e^imath left( x_p_f + 1 f - x_0 c right) theta    cdots    e^imath left( x_p_f + 1 f - x_p_c + 1 c right) theta  \nendbmatrix\nright) Q_c","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"and tildeR_ftoc is given by the transpose.","category":"page"},{"location":"background/#Multigrid-Error-Propagation-Operator","page":"Mathematical Background","title":"Multigrid Error Propagation Operator","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Combining these elements, the symbol of the error propagation operator for p-type multigrid is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"E left( p theta right) = S_f left( p theta right) left I - tildeP_ctof left( theta right) tildeA_c^-1 left( p theta right) tildeR_ftoc left( theta right) tildeA_f left( theta right) right S_f left( p  theta right)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where tildeP_ctof and tildeR_ftoc are given above, S_h is given by the smoothing operator, and tildeA_c and tildeA_f are derived from the PDE being analyzed.","category":"page"},{"location":"public/pc_pmultigrid/#Preconditioner:-P-Multigrid","page":"Preconditioner: P-Multigrid","title":"Preconditioner: P-Multigrid","text":"","category":"section"},{"location":"public/pc_pmultigrid/#Examples","page":"Preconditioner: P-Multigrid","title":"Examples","text":"","category":"section"},{"location":"public/pc_pmultigrid/","page":"Preconditioner: P-Multigrid","title":"Preconditioner: P-Multigrid","text":"This is an example of a simple p-multigrid preconditioner.","category":"page"},{"location":"public/pc_pmultigrid/","page":"Preconditioner: P-Multigrid","title":"Preconditioner: P-Multigrid","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex4_pmultigrid.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/pc_pmultigrid/","page":"Preconditioner: P-Multigrid","title":"Preconditioner: P-Multigrid","text":"This is an example of a multilevel p-multigrid preconditioner.","category":"page"},{"location":"public/pc_pmultigrid/","page":"Preconditioner: P-Multigrid","title":"Preconditioner: P-Multigrid","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex5_pmultigrid_multilevel.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/pc_pmultigrid/#Documentation","page":"Preconditioner: P-Multigrid","title":"Documentation","text":"","category":"section"},{"location":"public/pc_pmultigrid/","page":"Preconditioner: P-Multigrid","title":"Preconditioner: P-Multigrid","text":"PMultigrid\ncomputesymbols(::PMultigrid, ::Array, ::Array{Int}, ::Array)","category":"page"},{"location":"public/pc_pmultigrid/#LFAToolkit.PMultigrid","page":"Preconditioner: P-Multigrid","title":"LFAToolkit.PMultigrid","text":"PMultigrid(fineoperator, coarseoperator, smoother, prolongation)\n\nP-Multigrid preconditioner for finite element operators\n\nArguments:\n\nfineoperator:      finite element operator to precondition\ncoarseoperator:    coarse grid representation of finite element operator to                          precondition\nsmoother:          error relaxation operator, such as Jacobi\nprolongationbases: element prolongation bases from coarse to fine grid\n\nReturns:\n\nP-multigrid preconditioner object\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nctofbasis = TensorH1LagrangeBasis(3, 5, 2, lagrangequadrature=true);\n\n# operators\nfinediffusion = GalleryOperator(\"diffusion\", 5, 5, mesh);\ncoarsediffusion = GalleryOperator(\"diffusion\", 3, 5, mesh);\n\n# smoother\njacobi = Jacobi(finediffusion);\n\n# preconditioner\nmultigrid = PMultigrid(finediffusion, coarsediffusion, jacobi, [ctofbasis]);\n\n# verify\nprintln(multigrid)\nprintln(multigrid.fineoperator)\n\n# output\np-multigrid preconditioner\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\ntensor product basis:\n    numbernodes1d: 5\n    numberquadraturepoints1d: 5\n    dimension: 2\n  evaluation mode:\n    gradient\noperator field:\ntensor product basis:\n    numbernodes1d: 5\n    numberquadraturepoints1d: 5\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\ntensor product basis:\n    numbernodes1d: 5\n    numberquadraturepoints1d: 5\n    dimension: 2\n  evaluation mode:\n    gradient\n\n\n\n\n\n","category":"type"},{"location":"public/pc_pmultigrid/#LFAToolkit.computesymbols-Tuple{PMultigrid,Array,Array{Int64,N} where N,Array}","page":"Preconditioner: P-Multigrid","title":"LFAToolkit.computesymbols","text":"computesymbols(multigrid, p, v, θ)\n\nCompute or retrieve the symbol matrix for a Jacobi preconditioned operator\n\nArguments:\n\nmultigrid: PMultigrid preconditioner to compute symbol matrix for\np:         Smoothing paramater array\nv:         Number of pre and post smooths\nθ:         Fourier mode frequency array (one frequency per dimension)\n\nReturns:\n\nSymbol matrix for the p-multigrid preconditioned operator\n\nExample:\n\nusing LinearAlgebra\n\nfor dimension in 1:3\n    # setup\n    mesh = []\n    if dimension == 1\n        mesh = Mesh1D(1.0);\n    elseif dimension == 2\n        mesh = Mesh2D(1.0, 1.0);\n    elseif dimension == 3\n        mesh = Mesh3D(1.0, 1.0, 1.0);\n    end\n    ctofbasis = TensorH1LagrangeBasis(3, 5, dimension, lagrangequadrature=true);\n\n    # operators\n    finediffusion = GalleryOperator(\"diffusion\", 5, 5, mesh);\n    coarsediffusion = GalleryOperator(\"diffusion\", 3, 5, mesh);\n\n    # smoother\n    jacobi = Jacobi(finediffusion);\n\n    # preconditioner\n    multigrid = PMultigrid(finediffusion, coarsediffusion, jacobi, [ctofbasis]);\n\n    # compute symbols\n    A = computesymbols(multigrid, [1.0], [1, 1], π*ones(dimension));\n\n    # verify\n    using LinearAlgebra;\n    eigenvalues = real(eigvals(A));\n    if dimension == 1\n       @assert max(eigenvalues...) ≈ 0.6483564034574688\n    elseif dimension == 2\n       @assert max(eigenvalues...) ≈ 0.9146138945439544\n    elseif dimension == 3\n       @assert max(eigenvalues...) ≈ 1.4387790627121388\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"#LFAToolkit","page":"Introduction","title":"LFAToolkit","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Local Fourier Analysis for arbitrary order finite element type operators","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Local Fourier Analysis is a tool commonly used in the analysis of multigrid and multilevel algorthms for solving partial differential equations via finite element or finite difference methods. This analysis can be used to predict convergance rates and optimize parameters in multilevel methods and preconditioners.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides a toolkit for analyzing the performance of preconditioners for arbitrary, user provided weak forms of partial differential equations.","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"background.md\",\n    \"public.md\",\n    \"private.md\",\n    \"references.md\"\n]\nDepth = 1","category":"page"},{"location":"private/mesh/#Rectangular-Mesh","page":"Rectangular Mesh","title":"Rectangular Mesh","text":"","category":"section"},{"location":"private/mesh/","page":"Rectangular Mesh","title":"Rectangular Mesh","text":"LFAToolkit.Mesh","category":"page"},{"location":"private/mesh/#LFAToolkit.Mesh","page":"Rectangular Mesh","title":"LFAToolkit.Mesh","text":"Rectangular mesh with independent scaling in each dimesion\n\n\n\n\n\n","category":"type"}]
}
